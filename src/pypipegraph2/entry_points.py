import networkx
import os
from pathlib import Path
import sys
import subprocess


def browse_graph_ml(filename=None):
    graph = networkx.readwrite.graphml.read_graphml(filename)

    header = "choose a node by typing. Ctrl-c to quit"
    p = subprocess.Popen(
        ["fzf", "--header", header], stdin=subprocess.PIPE, stdout=subprocess.PIPE
    )
    chosen = p.communicate("\n".join(graph.nodes).encode("utf-8"))[0].decode("utf-8")
    stack = [chosen]

    if chosen:
        while True:
            if chosen.startswith("parent: ") or chosen.startswith("child: "):
                chosen = chosen[chosen.find(" ") + 1 :]
            chosen = chosen.strip()
            lines = []
            for child in reversed(sorted(graph.successors(chosen))):
                lines.append(f"child: {child}")
            lines.append("")
            for parent in reversed(sorted(graph.predecessors(chosen))):
                lines.append(f"parent: {parent}")
            lines = "\n".join(lines)
            header = f"Examining: {chosen}"
            p = subprocess.Popen(
                ["fzf", "--header", header],
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
            )
            chosen = p.communicate(lines.encode("utf-8"))[0].decode("utf-8")
            if not chosen:
                if len(stack) > 1:
                    chosen = stack.pop()
                    chosen = stack.pop()
                else:
                    break
            else:
                if not stack or stack[-1] != chosen:
                    stack.append(chosen)


def cli_browse_graph_ml():
    try:
        filename = sys.argv[1]
    except IndexError:
        print("ppg2_browse_graph_ml <path_to_.graphml>")
        sys.exit(1)
    browse_graph_ml(filename)


def record_as_generated_file(filename, history):
    import pypipegraph2 as ppg2

    if not filename.exists():
        raise FileNotFound(filename)

    present = filename in history
    print("already present?", present)
    if present:
        had_input = bool(history[filename][0])
        had_output = bool(history[filename][1])
        print("had output", had_output)
        print("had input", had_input)
    if not present or (not had_output) and (not had_input):
        print("ok, fixing,", filename)
        history[filename] = (
            {},
            {str(filename): ppg2.hashers.hash_file(filename)},
        )
    else:
        print("skipping", filename)


def cli_record_as_generated_file():
    """Record <filename> (relative path) as if it was
    done by a filegenerating job - provided it wasn't recorded
    previously, and it had no input.

    This should not be necessary in almost all circumstances.

    """
    import pypipegraph2 as ppg2

    if len(sys.argv) <= 1:
        print("ppg2_record_as_generated_file <filename>")
        print("Records this file as if it had been generated by the pipegraph")
        print("(only useful if the job in question is not being invalidated")
        sys.exit(1)
    else:
        g = ppg2.new()
        history = g._load_history()

        for filename in sys.argv[1:]:
            record_as_generated_file(Path(filename), history)
        g._save_history(history)


def usage_filename_patch():
    print("ppg2_filename_patch search_regexps replacement_use_\\1_for_groups folders")
    print("if folders is not set, assume cache & results")
    print("This is a hail mary - not certain it will replace quite enough to not rebuild anything")
    print("but it should help a bit, I suppose")
    sys.exit(1)


def cli_filename_patch():
    """Rename all filenames in folder Z containg X by replacing X with Y, and patch history accordingly
    ppg2_filename_patch query replacement [folders]

    """
    import pypipegraph2 as ppg2
    import re

    g = ppg2.new()
    history = g._load_history()

    try:
        query = sys.argv[1]
        replacement = sys.argv[2]
        folders = [x for x in sys.argv[3:] if not x.startswith("--")]
        if not folders:
            folders = ["cache", "results"]
        doit = '--doit' in sys.argv
    except IndexError:
        usage_filename_patch()
    reg = re.compile(query)
    renames = {}
    job_id_todo = []
    all_todos = set()
    for job_id, (inputs, outputs) in history.items():
        printed = False
        for what, entries in [("input", inputs), ("output", outputs)]:
            todo = []
            for k in entries:
                if reg.search(k):
                    if not printed:
                        print("job", job_id)
                        printed = True
                    print(f"\told {what}: {k}")
                    new = reg.sub(replacement, k)
                    print(f"\tnew {what}: {new}")
                    todo.append((k, new))
                    renames[k] = new
            for k, new in todo:
                entries[new] = entries[k]
                del entries[k]
            all_todos.update(todo)
        if reg.search(job_id):
            new = reg.sub(replacement, job_id)
            if not printed:
                print("job", job_id)
            print(f"\tjob old {job_id}")
            print(f"\tjob new {new}")
            printed = True
            job_id_todo.append((job_id, new))

        if printed:
            print("")
    for k, new in job_id_todo:
        history[new] = history[k]
        del history[k]
    all_todos.update(job_id_todo)

    dirs_to_clean = set()
    for old, new in all_todos:
        if not Path(old).exists():
            if old.startswith("FI") or old.startswith("CleanUp") or old.startswith("PI") or ":::" in old:
                pass
            else:
                print("Could not find file", old)
                print("")
        else:
            print(f"rename old: {old}")
            print(f"rename new: {new}")
            print("")
            if doit:
                dirs_to_clean.add(Path(old).parent)
                Path(new).parent.mkdir(exist_ok=True, parents=True)
                Path(old).rename(new)
    if doit:
        for d in dirs_to_clean:
            if not list(Path(d).glob("*")) and not list(Path(d).glob(".*")):
                print("unlinking empty dir", d)
                os.rmdir(d)

    if doit:
        g._save_history(history)
    else:
        print("Carefully review those changes, then rerun with '--doit'")


    # for folder in folders:
    # print("Searching in", folder)
    # folder = Path(folder)
    # for fn in folder.glob("**/*"):
    #     if query in str(fn):
    #         print(fn, str(fn) in history)
    # g._save_history(history)
